# 8. 통합점: 게이트웨이, 터널, 릴레이

## 8.1 게이트웨이
- 웹에 복잡한 리소스를 올려야할 때 한 개의 애플리케이션으로만 처리할 수 없어서
- 리소스를 받기위한 경로를 안내하는 역할을 하는 게이트웨이를 고안
- 게이트웨이: 리소스와 애플리케이션을 연결하는 역할
- 요청을 받고 응답을 보내는 포털같이 동작
- 동적인 콘텐츠를 생성하거나 데이터베이스에 질의를 보낼 수 있다.
- HTTP 트래픽을 다른 프로토콜로 자동변환하여 클라이언트가 다른 프로토콜을 알 필요없이 서버에 접속하도록 함
- 클라이언트, 서버와 통신하는 프로토콜이 다를 때 ```클라이언트 측 프로토콜/서버 측 프로토콜```로 구분해 기술
- 브라우저에 명시적으로 게이트웨이를 설정하여 트래픽이 게이트웨이를 거쳐가게 하거나 게이트웨이를 대리서버로 설정할 수 있다.

1. HTTP/*: 서버 측 웹 게이트웨이: 클라이언트로부터 HTTP요청이 원 서버 영역으로 둘어오는 시점에 HTTP요청을 외래 프로토콜로 전환한다.
2. HTTP/HTTPS: 서버측 보안 게이트웨이: 모든 웹 요청을 암호화함으로서 보안 제공. 게이트웨이가 사용자의 모든 세션을 암호화함
3. HTTPS/HTTP: 클라이언트 측 보안 가속 게이트웨이: 보안 HTTPS 트래픽을 받아 복호화하고 웹서버로 보낼 일반 HTTP요청을 만든다. 

### 8.1.1 리소스 게이트웨이
- 애플리케이션 서버는 목적지 서버와 게이트웨이를 한 개의 서버로 결합한다.
- 애플리케이션 서버: HTTP를 통해 클라이언트와 통신하고 서버 측에 있는 애플리케이션 프로그램에 연결하는 서버측 게이트웨이
- 요청 > 애플레이케이션 서버 > API(Application Programming Interface)를 통해 서버에서 동작하고 있는 애플리케이션에 전달
- CGI: HTTP 요청에 따라 프로그램을 실행하고 HTTP 응답으로 회신하는데 웹 서버가 사용하는 표준화된 인터페이스 집합
  - 웹에서 동적인 HTML, 신용카드 처리, 데이터베이스 질의 등을 제공하는데 사용
  - 거의 모든 리소스 형식과 서버의 접점에 있으면서 필요에 따라 변형, 처리하는 기능 제공
  - 문제가 많은 확장으로부터 서버를 보호
- 서버확장 API
  - CGI 프로토콜로 구동 중인 HTTP 서버에 외부 인터프리터가 접속할 수 있게 해주지만 서버 동작을 바꾸거나 처리능력을 바꾸고 싶을 때
  - 자신의 모듈을 HTTP와 직접 연결할 수 있는 인터페이스
  - 자신의 코드를 서버에 연결하거나 서버의 컴포넌트를 자신이 만든 것으로 교체할 수 있게 함
- HTTP가 애플리케이션을 연결하는 도구로 활용할 수 있음. 연결하면서 데이터를 교환하려는 두 앱 사이에 프로토콜 인터페이스를 맞추는 일이 이슈

## 8.2 터널
- HTTP 프로토콜을 지원하지 않는 앱에 HTTP앱을 사용해 접근하는 방법 제공
- HTTP 커넥션을 통해 HTTP가 아닌 트래픽 전송할 수 있고
- 다른 프로토콜을 HTTP 위에 올릴 수 있다

1. 커넥션 맺기
   1. CONNECT 메서드를 사용하여 커넥션을 맺음
      1. 예 ```CONNECT home.netscape.com:443 HTTP1.0 // 호스트명, 포트```
   2. TCP 커넥션이 ㅐㅇ성
   3. 게이트웨이는 클라이언트에서 ```HTTP 200 Connection Established``` 전송하여 연결 알림
   4. 터널이 연결됨
   5. HTTP 터널을 통해 전송된 클라이언트의 데이터는 TCP 커넥션으로 바로 전달. 서버로부터 전송된 데이터로 HTTP 터널을 통해 클라이언트로 전
2. SSL 터널링
   1. 방화벽을 통해 암호화된 SSL 트래픽을 전달하려고 개발됨
   2. SSL 트래픽을 HTTP 커넥션으로 전송하여 80포트 HTTP만 허용하는 방화벽 통과 - HTTP에 터널링 기능이 추가됨
      1. HTTP 메시지에 암호화된 날 데이터를 담고 일반 HTTP 채널을 통해 데이터를 전송
   3. SSL 커넥션이 맺어있다면 SSL 트래픽을 클라이언트 > 서버로 바로 전송할 수 있음
   4. 그렇지 않을 경우
      1. SSL 트래픽은 HTTP 메시지에 담겨 80 포트에 전송
      2. 터널(HTTP가 아닌 트래픽이 포트를 제한하는 병화벽을 통과할 수 있게 해줌)을 통해 SSL 트래픽 유입
      3. 터널에서 443포트에 전송할 SSL트래픽을 HTTP 커넥션을 통해 전송
3. SSL 터널링 vs. HTTP/HTTPS 게이트웨이
   1. 원격 HTTPS 서버와 SSL 세션을 시작하는 게이트웨이를 두고 HTTPS 트랜잭션을 수행할 수 있으나
      1. 클라이언트-게이트웨이 사이에 보안이 적용되지 않은 일반 HTTP 커넥션이 맺어져 있고
      2. 프락시가 인증을 담당하고 있어, 원격 서버에 SSL 클라이언트 인증을 할 수 없고
      3. 게이트웨이가 SSL을 완벽히 지원해야 해서 단점
   2. 그래서 SSL 터널링을 사용하면 프락시에 SSL을 구현할 필요가 없다
      1. SSL 세션은 클라이언트가 생성한 요청과 목적지 웹 서버간에 생성
      2. 프락시 서버는 보안에 관여하지 않고 암호화된 데이터를 그대로 터널링할 뿐
4. 터널은 클라이언트와 게이트웨이 사이에 위치하여, 클라이언트가 터널을 사용할 수 있는 권한을 검사하는 용도로 프락시 인증을 사용할 수 있다.
   1. CONNECT 요청(클라-게이트)
   2. 인증요구(게이트-클라)
   3. 인증(클라-게이트)
   4. 443 포트로 TCP 커넥션 맺음

## 8.3 릴레이
- HTTP 명세를 완전히 준수하지는 않는 간단한 HTTP 프락시
- 커넥션을 맺기위한 HTTP 통신 후 바이트를 맹목적으로 전달
- 단순 필터링이나 진단, 콘텐츠 변환에 사용되기도 함
- 문제는, 맹목적 릴레이가 connection헤더를 제대로 처리하지 못해서 keep-alive 커넥션이 행에 걸리는 것
  - ```클라이언트 >>>/<<< Connection:Keep-Alive >> 무조건 릴레이 >>>/<<< Connection:Keep-Alive```
    - 클라이언트가 릴레이에 keep-alive 커넥션 맺기를 원하는 요청을 보냄
    - 릴레이는 요청을 받았지만 Connection헤더를 이해하지 못하고 서버로 보냄
    - Connection 헤더는 홉과 홉 사이에만 사용하는 헤더. 체인을 따라 전달할 수 없음
    - 서버는 요청을 받고 릴레이가 keep-alive 하려는구나 결론
    - 서버는 릴레이와 keep-alive 통신 시작
    - 릴레이는 k-a를 몰라요....
    - 릴레이는 서버에서 응답을 받아 클라이언트에 전달
    - 클라이언트는 응답을 받고 릴레이가 keep-alive에 동의한다고 추측
    - 릴레이는 원서버가 커넥션 끊기를 기다리며 받은 데이터 전부를 클라이언트에 전달
    - 커넥션 끊길 때를 기다리며 계션 커넥션을 맺고(hang)있음
    - 클라이언트가 다음 요청을 keep-alive 커넥션을 통해 릴레이에게 전송
    - 같은 커넥션에서 또 요청이 오는것을 예측하지 못한 릴레이는 작업을 안 한다
    - 
