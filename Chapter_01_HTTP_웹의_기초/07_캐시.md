# 7. 캐시

- 자주 쓰이는 문서의 사본을 자동으로 보관하는 HTTP 장치
- 같은 문서에 대한 요청을 계속 전송하면 똑같은 바이트들이 네트워크를 통해 반복적으로 이동하고 대역폭을 많이 사용 -> 응답을 캐시에 보관하여 중복해서 트래픽을 주고받는 낭비를 줄임
- 보통 원격 서버보다 로컬 네트워크 클라이언트에 넓은 대역폭을 제공. 큰 문서 > 대역폭 많이 사용 > 지연. 대역폭을 늘리지 않고도 페이지를 불러와 네트워크 병목을 줄여줌
- 원서버에 대한 요청을 줄여 부하를 줄인다
- 거리로 인한 지연을 줄인다

## 7.1 적중과 비적중
- 캐시에 요청에 도착했을 때
  - 대응하는 사본이 있으면 요청처리할 수 있음 = 캐시 적중(cache hit)
  - 대응하는 사본이 없으면 원서버로 전달 = 캐시 부적중(cache miss) 
- HTTP 재검사
  - 캐시는 갖고있는 사본이 여전히 최신인지 서버를 통해 검사
  - 클라이언트가 사본을 요청했을 때 그 사본이 검사가 필요할 정도로 오래된 경우에만
  - 검사 요청 결과 ```304 Not Modified``` 면 유효한 사본 = 재검사 적중, 느린 적중(원 서버와 검사를 거친 것)
  - ```If-Modified-Since``` 헤더: 캐시된 시간 이후에 변경됐을 때만 사본을 보내달라는 의미
    1) 콘텐츠가 변경되지 않은 경우: 재검사 적중(```304 Not Modified```)
    2) 콘텐츠가 변경된 경우: 서버에서 콘텐츠를 보내줌(```200 Ok```)
    3) 객체가 삭제된 경우: ```404 Not Found```를 보내고 캐시는 사본 삭제
- 적중률
  - 캐시가 요청을 처리하는 비율(0~1, 0~100%)
  - 40%면 무난
  - 얼마나 많은 웹 트랜잭션을 외부로 내보내지 않았는지 보여줌
  - 문서 적중률을 개선하면 전체 대기시간(지연)이 줄어든다
- 바이트 적중률
  - 캐시를 통해 제공된 바이트의 비율. 트래픽이 절감된 정도를 포착할 수 있음
  - 얼마나 많음 바이트가 인터넷으로 나가지 않았는지를 보여줌
  - 대역폭 절약을 최적화
- 응답이 캐시에서 온건지 확인하려면 Date 헤더값을 현재 시각과 비교해서 확인하거나 Age 헤더를 이용할 수 있음

## 7.2 캐시 토폴로지
1. 개인 전용 캐시(private cache)
   - 한 명에게만 할당된 캐시
   - 웹 브라우저는 개인 전용 캐시를 내장함
   - 개인 컴퓨터 디스크와 메모리에 캐시함
2. 공용 프락시 캐시(public cache)
   - 캐시 프락시 서버, 프락시 캐시라고 불리는 공유된 프락시 서버
   - 로컬 캐시에서 문서를 제공하거나 사용자 입장에서 서버에 접근
   - 여러 사용자가 접근하여 불필요한 트래픽을 줄일 수 있다.
   - 자주 찾는 객체를 한번만 가져와 모든 요청에 대해 공유된 사본을 제공
   - 수동/자동으로 프락시를 설정할 수 있음
3. 프락시 캐시 계층
   - 작은 캐시에서 캐시 부적중 -> 부모 캐시가 남겨진 트래픽을 처리하도록 계층을 만듦(두 단계의 캐시 계층)
   - 클라이언트 주위에는 작고 저렴한 캐시. 계층상단에 많은 사용자들에 공유되는 문서 유지
   - 캐시 계층이 깊으면 긴 연쇄를 따라가서 중간 프락시는 성능저하가 현저히 발생할 것
4. 캐시망, 콘텐츠 라우팅, 피어링
   - 복잡한 캐시망을 만들어서 어떤 부모캐시와 대화할 것인지, 원서버로 가게 할 것인지 동적으로 캐시 커뮤니케이션을 결정
   - 캐시망 안에서 콘텐츠 라우팅을 위해 캐시 설계
   - URL에 근거하여 부모캐시, 원서버 중 하나를 동적으로 선택
   - URL에 근거하여 특정 부모캐시를 동적으로 선택
   - 부모 캐시로 가기 전 캐시된 사본을 로컬에서 찾아본다
   - 다른 캐시들이 그 캐시된 콘텐츠에 부분적으로 접근할 수 있도록 하영하지만 캐시를 통한 인터넷 트랜짓(트래픽이 다른 네트워크로 건너감)은 허용하지 않음
   - 서로 다른 조직들이 상호 이득을 위해 캐시를 연결하여 서로 찾아볼 수 있도록 함. (피어링. 형제 캐시) 
   - HTTP는 형제 캐시를 지원하지 않음 -> ICP(인터넷 캐시 프로토콜), 하이퍼텍스트 캐시 프로토콜(HTCP)로 HTTP 확장
   
## 7.3 캐시 처리 단계
1. 요청 받기: 네트워크 커넥션에서의 활동을 감지하고 들어오는 데이터를 읽음
2. 파싱: 요청메시지를 여러 부분으로 파싱하여 자료구조에 담는다. 
3. 검색: URL에 해당하는 로컬사본이 있는지 검사. 로컬에서 가져올 수 없으면 원 서버나 부모 프락시에서 가져오거나 실패 반환
4. 신선도 검사
   1. 캐시가 일정기간 동안 서버 문서의 사본을 보유할 수 있도록 하지만 너무 오래 있었으면 신선하지 않은 것으로 간주
   2. 문서를 제공하기 전 문서에 변경이 있었는지 원서버와 재검사
5. 응답 생성
   1. 원서버 응답처럼 캐시된 서버 응답 헤더를 토대로 생성
   2. 캐시 신선도 정보 삽입(Cache-Control, Age, Expires, Via 헤더)
   3. Date 헤더는 원서버에서 최초로 생겨난 일시를 표현하는 것. 수정하면 안 됨
6. 전송
   1. 응답 헤더를 클라이언트에게 전달
   2. 클라이언트와 커넥션 유지
7. 로깅
   1. 통계 캐시 적중과 부적중 횟수 통계 갱신. 요청종류, URL 등 기록
   2. 스퀴드 로그 퐷, 넷스케이프 확장 공용 로그 포맷이 널리 쓰임 

## 7.4 사본을 신선하게 유지
- ```Cache-Control```, ```Expires``` 헤더를 이용해 원 서버가 문서에 유효기간을 붙일 수 있게 함
- 캐시문서가 만료되면 반드시 서버와 문서변경에 대해 검사하고 신선한 사본을 얻어와야 함
- ```HTTP 1.0+ Expries```, ```HTTP1.1 Cache-ControlL max-age```에 유효기간 명시
  - ```max-age```: 문서 생성 이후부터 신선하지 않는 문서가 될 때까지의 최대 나이
- 캐시는 
  - 충분히 신선한 캐시된 사본이나
  - 재검사를 마친 신선한 사본이나
  - 에러메시지나
  - 경고메시지가 있는 사본을 보내야 한다

1. 조건부 메서드: 서버가 갖고있는 문서가 캐시가 가진 것과 다를 때만 보내달라고 요청하는 것
  - ```If-Modified-Since```
    - 이 날짜 이후로 변경되었다면 요청메서드 처리. ```Last-Modified``` 헤더와 새 문서, 새 만료날짜가 반환됨
    - 변경이 없으면 ```304 Not Modified```. 갱신이 필요한 것(예. 새 만료 날짜)만 보냄
  - ```If-None-Match```
    - 사소한 변경이나 내용에 변함없이 갱신된 문서, 정확한 변경일시를 판별할 수 없을 때, 변경일이 1초 미만일 때 변경일시 재검사가 어려움. 
    - 문서의 특정 태그(ETga)를 붙이는데 캐시된 태그와 원서버 문서의 태그와 다를 때만 요청 처리

2. 약한 검사기, 강한 검사기
  - 엔터티 태그, 변경일시는 모두 캐시 검사기
  - 문서를 살짝 바꾸고 그 정도면 같은 것으로 처리하고 싶을 때 ```약한 검사기``` 지원. ```w/```로 구분함
  - ```강한 검사기```는 콘텐츠가 바뀔 때마다 바뀜

3. 엔터티 태그 vs. Last-Modified 일시
  - HTTP/1.1 클라이언트는 서버가 엔터티 태그를 반환했다면 엔터티 태그 검사기를 이용해야 함
  - 서버가 Last-Modified를 반환했으면 If-Modified-Since 검사 이용

## 7.5 캐시 제어
- ```Cache-Control: no-store```
  - 캐시가 검증되지 않은 캐시된 객체로 응답하는 것을 막음
  - 캐시가 사본 만드는 것을 금지
- ```Cache-control: no-cache```
  - 서버와 재검사를 하지 않고 캐시에서 클라이언트로 제공 금지
- ```Cache-control: mush-revalidate```
  - 캐시가 만료정보를 엄격히 따르도록 함
  - 서버와 최초 재검사 없이는 제공하면 안됨
  - 신선도 검사를 하려는데 서버를 이용 못 하는 상황이면 ```504 Gateway Timeout error``` 반환
- ```Cache-Control: max-age```
  - 문서가 서버로부터 온 이후 흐른 시간. 초로 표현
  - ```s-maxage``` 헤더는 공용 캐시에만 적용
- ```Expires```
  - deprecated
  - 실제 만료날짜 명시
  - 0이면 항상 만ㄹ
- 휴리스틱 만료
  - Cache-Control헤더나 Expires헤더가 다 미포함일 때 경험적인 방법으로 최대 나이 계산

- 브라우저의 리프레시, 리로드 버튼으로 프락시 캐시의 신선하지 않은 콘텐츠를 강제 갱신
  - 리프레시버튼은 Cache-Control 요청헤더가 추가된 GET 요청을 발생
  