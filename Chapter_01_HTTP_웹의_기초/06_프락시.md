# 6. 프락시

## 6.1 웹 중개자
- 클라이언트 입장에서 트랜잭션을 수행하는 중개인. (서버와 직접 얘기하는 대신)
- 프락시 서버는 HTTP클라이언트 요청을 받아 응답을 돌려주는 웹 서버, 요청을 서버로 보내고 응답을 받는 HTTP 클라이언트이기도 함
- 공용프락시(여러 클라이언트가 사용하는 공유된 프락시), 개인전용 프락시(하나의 클라이언트가 독점적 사용)가 있다.
- 프락시 vs. 게이트웨이
    - 프락시: 같은 프로토콜을 사용하는 둘 이상의 애플리케이션을 연결
    - 게이트웨이: 서로 다른 프로토콜을 사용하는 둘 이상을 연결. 클라이언트와 서버가 서로 다른 프로토콜로 말해도 서로간의 트랜잭션을 완료할 수 있도록 변환기처럼 동작
    
## 6.2 프락시 사용 이유
- 예) 필터링 프락시: 부적절한 사이트 접근 거부
- 문서 접근 제어자: 중앙에서 접근 제어, 감사추적(비밀번호 요구 등)
- 보안 방화벽: 들어오거나 나가는 응용 레벨 프로토콜의 흐름을 네트워크 한 지점에서 통제
- 웹 캐시: 인기있는 문서의 로컬 사본을 저장하고 해당 문서에 대해 요청을 빠르게 처리
- 대리 프락시: 웹 서버인 것처럼 위장. 공용 콘텐츠에 대한 느린 웹 서버의 성능을 개선하기 위해 사용(서버 가속기)
- 콘텐츠 라우터: 인터넷 트래픽 조건과 콘텐츠의 종류에 따라 요청을 특정 웹 서버로 유도. 
- 트랜스 코더: 데이터 표현 방식을 자연스럽게 변환(트랜스 코딩) 예. 이미지 색 강도 조정, 텍스트 파일 압축. 외국어 변환
- 익명화 프락시: 신원을 식별할 수 있는 IP주소,User-Agent헤더, From헤더, Referer 헤더, 쿠키, URI세션 아이디 등을 제거하여 개인정보 보호, 익명성 보장

## 6.3 프락시 위치
1. 프락시 서버 배치
    - 출구 프락시: 로컬네트워크와 더 큰 인터넷 사이를 오가는 트래픽 제어를 위해 **로컬 네트워크 출구**에 배치. (방화벽, 필터링 등)
    - 접근(입구) 프락시: 요청을 종합적으로 처리하기 위해 **ISP 접근 지점**에 위치(다운로드 속도 개선, 캐시 프락시)
    - 대리 프락시: 네트워크 가장 끝에 있는 **웹 서버 바로 앞**에 위치. 웹 서버로 향하는 모든 요청을 처리하고 필요할 때만 웹 서버에 자원 요청.
    - 네트워크 교환 프락시: 캐시를 이용해 인터넷 교차로의 혼잡을 완화, 트래픽 감시. **네트워크 사이의 인터넷 피어링 교환 지점**에 놓임

2. 프락시 계층
    - 프락시는 연쇄(프락시 계층)를 구성할 수 있다.
    - 서버에 가까운 쪽(인바운드)이 부모. 클라이언트에 가까운 쪽(아웃바운드)이 자식
    - 순서대로 메세지를 보냄(정적)
    - 부모의 작업량 수준에 근거한 부하 분산, 지리적 인접성에 따라, 프로토콜/타입에 따라 동적으로 부모를 선택하여 라우팅할 수 있다.
    
3. 트래픽 처리 방법
    - 클라이언트 트래픽이 프락시로 가도록 한다.
    - 클라이언트(브라우저) 수정 - 자동/수동 프락시 설정 지원
    - 네트워크 인프라를 가로채서 웹 트랙픽을 프락시로 가도록 조정 - 스위칭 장치와 라우팅 장치 필요 (인터셉트 프락시)
    - 대리프락시는 웹서버의 이름과 IP주소를 직접 사용 -> 모든 요청이 서버 대신 대리프락시로 간다. DNS를 수정해서 실제 서버의 IP주소와 이름은 변경되고 대리프락시는 이전 이름, 주소를 사용
    - 웹서버가 503 리다이렉션 응답을 돌려줌 - 요청을 프락시로 리다이렉트 하도록 함
    
## 6.4 클라이언트 프락시 설정
1. 브라우저에서 프락시를 사용하겠다고 명시적으로 수동 설정
2. 브라우저 벤더나 배포자에 의해 기본적으로 미리 설정됨
3. 자바스크린트 프락시 자동설정(Proxy Auto-configuration, PAC)파일에 대한 URI 제공. 클라이언트에서 프락시를 쓰는지, 어떤걸 쓰는지 이 파일을 실행해서 봄
    - 프락시 설정에 대한 동적인 해결(프락시 설정을 상황에 맞게 계산해주는 자바스크립트 프로그램)
    - PAC파일의 URI를 브라우저에 설정
    - ```.pac``` 확장자, ```application/x-ns-proxy-autocoding``` MIME타입
    - URI에 접근할 때 사용할 프락시 서버를 계산해주는 ```FindProxyForUrl(url, host)```를 정의해야함
4. 자동설정 파일을 다운받을 수 있는 설정서버를 자동으로 찾아주는 웹 프락시 자동발견 프로토콜(Web Proxy Autodiscovery Protocol, WPAD) 제공
    - 브라우저에 맞는 PAC파일을 찾아주는 알고리즘
    - PAC URI를 찾기위해 WPAD를 사용 -> URI에서 PAC 파일을 가져옴 -> 파일을 실행하여 프락시 서버 알아냄 -> 요청 처리
    

## 6.5 프락시 요청 특징
- 클라이언트가 웹 서버로 요청을 보낼 때 - 스킴, 포트번호가 없는 부분 URI
    - 단일서버와 직접 대화
    - 서버는 자신의 호스트명과 포트번호를 알고 있으므로 클라이언트에서 불필요한 정보 발송을 피하기 위해
```
GET /index.html HTTP/1.0
User-Agent: SuperBrowserv1.3
```


- 클라이언트가 프락시로 요청을 보낼 때 - 완전한 URI를 가짐
    - 프락시가 목적지 서버와 커넥션을 맺기 위해 서버의 이름, 스킴이 필요 
```
GET http://www.hi.com/index.html HTTP/1.0
User-Agent: SuperBrowserv1.3
```

- 가상 호스팅 웹서버는 여러 사이트가 하나의 물리 서버를 공유 -> 스킴/호스트/포트번호가 누락돼서 오면 어떤 웹사이트로의 요청인지?
- 클라이언트에서 프락시 사용 설정이 안 되어 있어도 대리 프락시나 인터셉트 프락시를 지날 수 있다.
    - 이 때 완전하지 않은 URI로 보내고 있음
    - 대리 프락시는 원 서버의 호스트명과 아이피 주소를 사용하므로 괜찮다
    - 인터셉트 프락시는 서버로 가는 트래픽을 가로채기 떄문에 웹서버로 보내는 부분 URI을 얻는다.
- 완전한 URI가 주어졌으면 프락시는 그것을 사용해야 한다.
- 부분URI 
    - Host헤더에서 원 서버의 이름과 포트 번호를 알아내야 한다.
    - (Host헤더 없음) 대리 프락시라면 프락시에 실제 서버의 주소와 포트번호가 설정되었을 수 있다. 
    - (Host헤더 없음) 인터셉트 프락시가 가로챘던 트래픽을 받았고 인터셉트가 원IP, 포트번호를 사용하게 할 수 있게 해놨으면 사용
    - 다 실패하면 에러메시지 반환
    
- 몇몇 프락시는 URI를 다음 홉으로 보내기 전에 정규화
    - 기본 포트 명시
    - URI 클라이언트 자동확장
    - 호스트명 분석

- 명시적 프락시를 사용하면 부분 호스트명을 확장하지 않음. 입력받은 호스트명 그대로 보낸다.(기본 스킴은 추가)
- 인터셉트 프락시(보이지 않음. 클라이언트 입장에서는 없는 프락시)를 이용한 URI 분석
    - oreilly 타이핑
    - DNS를 통해 찾아보지만 실패
    - www.oreilly.com로 자동확장
    - DNS로 호스트명 얻음
    - 접속 시도. 실패하는 IP가 있을 수 있지만 프락시에 의해 종료된 것(원 서버 아님)
    - 프락시가 원서버와 상호작용할 준비가 되었을 때 그 IP가 다운된 서버를 가리키고 있음을 알게됨 -> 호스트명 분석, 역방향 DNS 룩업으로 IP를 찾아 시도해야
    
## 6.6 메시지 추적
- 웹 요청이 둘 이상의 프락시를 지나면서 메시지의 흐름을 추적하고 문제를 찾아내는 것이 중요해짐
1. Via 헤더
     ```
    Via: 1.1 proxy-62.irenes-isp.net, 1.0 chache.joes.com
   ```
    - 메시지가 지나는 중간 노드(프락시, 게이트 웨이)의 정보를 나열
    - 노드를 지날떄마다 Via목록 끝에 추가
    - 메시지 전달 추적. 메시지 루트 진단. 요청-응답에 관여하는 모든 발송자들의 프로토콜을 다루는 능력 체크
    - 네트워크의 라우팅 루프 탐지
    - 프락시가 요청을 보내기 전 자신을 가리키는 유일한 문자열을 Via 헤더에 삽입
    - 쉼표로 구분
    - 노드의 프로토콜과 주소에 대한 정보를 담음
    - 요청-응답은 같은 경로를 지나므로 응답의 Via헤더는 요청Via 헤더와 반대
    - 몇몇 프락시는 비 HTTP 프로토콜을 사용할 수 있는 게이트웨이 기능을 제공 -> 프로토콜 변환을 Via헤더가 기록 
    - Server 헤더(원서버에 의해 사용되는 소프트웨어 기록)를 수정하면 안 됨
    - 보안을 위해 호스트명을 적당한 가명으로 교체할 필요가 있음
    
2. TRACE 메서드
    - 프락시서버는 메세지가 전달될 때 메세지를 바꾸기도 함 
    - 이 변경로그를 관찰
    - 요청메시지를 프락시 연쇄를 따라가며 지나간 프락시와 메시지 수정기록을 관찰, 추적
    - **프락시 흐름을 디버깅**
    - ```Max-Forwards```헤더로 지나가는 프락시 갯수 제한. 
    
## 6.7 프락시 인증, 상호운용성
- 제한된 요청이 프락시 서버에 도착했을 때 요청 차단, 접근을 제한할 수 있음(```407 Proxy Authorization Required```)
- 이해할 수 없는 헤더필드는 그대로 전달해야 함
- 같은 이름의 헤더필드가 여러개 있을 경우 순서도 유지
- 지원하지 않는 메서드도 통과 시켜야 함
- ```OPTIONS``` 메서드: 서버나 웹서버의 특정 리소스가 어떤 기능을 지원하는지 확인할 수 있다.
    - * 로 보내면 서버 전체 능력을 묻는 것
    - 리소스 URI를 보내면 특정 리소스에 대한 기능 
- ```Allow```헤더: 요청에 의한 자원을 지원하는 메서드, 서버가 지원하는 모든 메서드를 열거(응답). 요청에 있는 Allow 헤더는 이것들을 지원해 달라는 추천의 의미.

    