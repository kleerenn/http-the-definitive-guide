# 10. HTTP/2.0

## 등장배경
- HTTP/1.1 메시지 포맷은 구현의 단순성, 접근성에 최작화 -> 성능은 떨어짐
- 요청 - 응답을 받고 다음 요청을 보내 심각한 회전 지연
- 구글의 SPDY 포로토콜: 기존 HTTP에 속도개선을 위해. 헤더를 압축하여 대욕폭을 절약. 하나의 TCP 커넥션에 여러 요청

## 개요
- 서버와 클라이언트 사이의 TCP 커넥션 위에서 동작. 클라이언트가 TCP 커넥션 초기화
- 요청과 응답은 길이가 정의된 한 개 이상의 프레임에 담겨 스트림을 통해 보내짐
- 한 개의 스트림 = 한쌍의 요청과 응답 처리
- 하나의 커넥션에 여러개의 스트림이 만들어질 수 있음 = 여러 요청과 응답을 동시에 처리
- 서버 푸쉬 도입: 클라이언트가 요청을 보내지 않아도 클라이언트에 필요하다고 생각하는 리소스라면 보내줌

## HTTP/1.1과의 차이점
1. 모든 메세지는 프레임에 담겨 전송됨. 각 필드는;
   - R: 예약된 2비트 필드. 값의 의미가 정의되어 있지 않고 반드시 0. 받는 쪽에서 무시함.
   - 길이: 페이로드의 길이
   - 종류: 프레임 종류
   - 플래그: 8비트
   - R: 예약된 1비트 필드
   - 스트림 식별자
  
2. 스트림, 멀티플렉싱
    - 스트림: HTTP2.0 커넥션을 통해 클라이언트와 서버 사이에서 교환되는 프레임들의 독립적 양방향 시퀀스
    - 한쌍의 요청-응답은 하나의 스트림을 통해
    - 새 스트림을 만들어 요청을 보내고 같은 스트림으로 응답을 보내고 스트림이 닫힘
    - HTTP1.1에서는 한 TCP커넥션으로 요청을 보내고 응답이 왔을 때 다시 요청을 보낼 수 있었음 -> 여러 TCP 커넥션을 만들어 복수 요청 
    - HTTP2.0에서는 한 커넥션에 여러 스트림 열릴 수 있음 -> 여러개의 요청이 동시에 보내질 수 있음. 요청 우선순위 적용 가능.
    - 서버와 클라이언트는 스트림을 일방적으로 만든다. 스트림을 만들 때 협상을 위해 TCP 패킷을 주고 받는 낭비를 피할 수 있음
    - 한 번 사용한 스트림 식별자는 재사용 불가. 식별자가 고갈되면 다시 커넥션을 맺으면 된다. 
3. 헤더 압축
   - 헤더의 크기가 회전지연과 대역폭에 영향을 끼침 -> 메세지의 헤더를 압축해서 전송함

4. 서버 푸쉬
   - 서버에서 한 요청에 대해 여러 응답을 리소스로 보낼 수 있음
   - 리소스 푸쉬할 것임을 PUSH_PROMISE 프레임을 보내 미리 알려주어야 한다 -> 해당 프레임은 예약됨 상태. 보내려고 하는 자원을 별도로 요청하게 되는 상황 방지
   - 중간의 프락시가 서버로 받은 추가 리소스를 클라이언트에 전달하지 않을 수 있고, 서버에서 받지 않은 리소스도 전달할 수 있다.
   - 오직 안전하고 캐시 가능하고 본문을 포함하지 않은 요청만 푸쉬
   - 푸쉬할 리소스는 클라이언트가 명시적으로 보낸 요청과 연관된 것이어야 함
   - 서버가 보낸 리소스를 Same-origin-policy에 따라 클라이언트에서 검사해야 함.
   - 서버 푸쉬를 끄려면 SETTING_ENABLE_PUSH = 0

## 보안이슈
- 중간 프락시가 HTTP1.1 메시지로 변환할 때 메시지 의미가 변질될 가능성이 있다.
- 2.0에서는 헤더필드의 이름, 값을 바이너리로 인코딩 -> 어떤 문자열이든 사용할 수 있게 되어 2.0의 요청이나 응답이 불법이나 위조된 1.1 메시지로 변역될 수 있다
- 오랜 커넥션 유지에서 개인정보 유출에 악용될 가능성이 있다