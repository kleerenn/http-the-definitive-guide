# 4. 커넥션 관리

## 4.1 TCP 커넥션
- HTTP 통신은 TCP/IP를 통해 이루어 진다.
- TCP/IP 커넥션을 맺어지면 클라이언트-서버 간 메세지가 손성없이 전달된다. ```신뢰할만한 통신방식 제공```
- URL 입력 후 브라우저가 수행하는 단계
    ```
  1. www.google.com 입력
  2. 호스트 명에 대한 IP 주소를 찾음
  3. 포트번호 얻음
  4. IP 주소, 포트번호로 TCP 커넥션 생성
  5. 서버로 요청을 보내고 응답을 받고 커넥션을 끊음
  ```
  
- TCP는 ```IP패킷```이라 불리는 작은 조각으로 데이터를 전달한다.
- HTTP(애플리케이션 계층) / TCP(전송 계층) / IP(네트워크 계층) / Network Interface
    - HTTPS는 HTTP - TCP 계층 사이 TLS or SSL(보안계층)
- HTTP로 메세지 보내기 위해
```
1. TCP 커넥션을 통해 메세지 데이터 내용을 순서대로 보냄 
2. 세그먼트 단위로 데이터 스트림을 나눔
3. 나눈 세그먼트를 IP 패킷에 담음(IP 패킷 헤더 + TCP 세그먼트 헤더 + TCP 데이터 조각)
4. 데이터 전달
```

### 4.1.1. TCP 커넥션 유지하기
- TCP는 포트번호를 통해 여러 커넥션을 유지
- IP 주소는 컴퓨터에 연결, 포트 번호는 애플리케이션에 연겨
- TCP 커넥션 ```<발신지IP, 발신지 포트, 수신지IP, 수신지 포트>```로 유일한 커넥션 생성
 
### 4.1.2 TCP 소켓 프로그래밍
- 소켓 API를 사용하면 TCP 종단 데이터 구조를 생성하고 원갹 서버의 TCP 종단에 종단 데이터구조를 연결하여 데이터 스트림을 읽고 쓸 수 있다.
- HTTP 트랜잭션 수행을 위한 소켓 API 사용법
```
1. 서버에서 소켓 생성. 커넥션 허가. 커넥션 기다림
2. 클라이언트에서 IP주소와 포트번호로 TCP 커넥션 생성. 소켓 생성
3. HTTP 요청 보냄
4. 응답 받고 커넥션 닫음
```
  
## 4.2 TCP 성능에 대한 고려
- HTTP는 TCP 바로 위에 있는 계층으로 HTTP 트랜잭션 성능은 TCP 성능에 영향을 받는다.
### 4.2.1 어떤 네트워크 지연이 발생하나
- HTTP 지연은 대게 TCP 네트워크 지연 때문에 발생
- 지연 원인
    - IP, 포트번호를 얻기위해 방문하지 않았던 호스트명을 IP 주소로 변환
    - TCP 요청을 보내고 서버가 커넥션 허가 응담 보내길 기다림
    - 요청 메세지가 보내지고 서버에서 처리하는 시간
    - 응답 보내는 시간

### 4.2.2. TCP 관련 지연
**1. TCP 커넥션 핸드셰이크**
- 핸드셰이크 순서
    ``` 
   1. 클라이언트에서 TCP커넥션 생성을 위해 TCP 패킷을 보냄(커넥션 생성 요청. SYN)
   2. 서버에서 커넥션 요청을 받아들이고 SYN, ACK 플래그를 포함한 TCP 패킷을 보냄
   3. 클라이언트에서 커넥션 맺어졌다는 확인응답을 보냄(데이터가 같이 갈 수도)
   ```
    - SYN / SYN+ACK 핸드셰이크가 지연을 발생시킴
    - TCP 구성에 HTTP 트랜잭션이 많이 소요됨(이미 존재하는 커넥션을 활용하는 것으로 개선 가능)

**2. 확인응답 지연**
- 각 TCP 세그먼트는 순번과 데이터 무결성 체크섬을 가진다.
- TCP 세그먼트 수신을 받으면 확인응답 패킷을 반환한다. 
- 이 응답은 크기가 작아서 같은 방향으로 가는 데이터 패킷에 편승시킨다.(데이터 패킷 + 획인응답)
- 편승할 데이터 패킷을 찾기 위한 시간 동안 확인응답이 버퍼에 잠시 저장된다.
- HTTP 통신은 요청, 응답만 있음 -> 확인응답이 데이터 패킷에 편승할 기회를 감소시킴.(확인응답이 편승할 데이터패킷이 많지 않아서 지연)

**3. TCP 느린 시작**
- TCP 데이터 전송속도는 커넥션이 생성된지 얼마나 지났나에 따라 달라질 수 있다
    - 처음에는 최대속도 제한 -> 점점 속도 제한을 높임 (느린 시작) => 갑작스런 부하 방지
- 느린시작: TCP가 한번에 전송할 수 있는 패킷의 수 제한
    - 확인응답 받고 다음 요청에 패킷 더 보낼 수 이는 식(opening the congestion window)
- 새로운 커넥션은 튜닝된 커넥션(이미 데이터를 주고 받은)보다 느리다.

**4. 네이글 알고리즘과 TCP_NODEPLAY**
- 어떤 크기의 데이터를 TCP 스택으로 전송할 수 있도록 데이터 스트림 인터페이스 제공
- 네이글 알고리즘?
    - 패킷을 전송하기 전 많은 TCP 데이터를 한 덩어리로 합치고 이 세그먼트가 최대크기가 되지 않으면 전송을 하지 않는다.
    - 확인응답을 받으면 최대크기보다 작은 패킷 전송도 허락.
    - but, 크기가 작은 http메시지를 보낼 때는 지연.

**5. TIME_WAIT 누적과 포트 고갈**
- TCP 종단에서 커넥션을 끊으면 커넥션의 IP 주소와 포트번호를 메모리의 제어 영역에 기록해 둔다. -> 일정 시간동안 같은 주소, 포트번호로 새 커넥션이 생성되지 않기 위함
- 성능시험을 할 때는 문제가 될 수 있음(사용할 수 있는 발신지 포트는 제한되어 있고 커넥션이 재사용 안되니까)

## 4.3 HTTP 커넥션 관리
### 4.3.1 Connection 헤더
- 헤더 필드는 커넥션 토큰을 쉼표로 구분 -> 다른 커넥션에 전달되지 않는다.(프락시 서버, 캐시 서버 등 중개서버를 거칠 수도 있는 경우..)
- 헤더 필드명은 이 커넥션에만 해당되는 헤더 나열
- Connection: close 는 작업완료 후 커넥션 종료되어야 함 의미
- 예
```
HTTP/1.1 200 Ok
Cache-control: max-age=3600
Connection: meter, close, bill-card // Meter 헤더를 다른 커넥션으로 전달하면 안된다. 트랜잭션이 끝나면 커넥션이 끊길 것
Meter: max-uses= 3
```
- 커넥션 토큰이 HTTP 헤더 필드명을 가지고 있으면 그 필드는 현재 커넥션만을 위한 정보이므로 다음 커넥션에 전달하면 안 된다.
- 다음 홉에 전달하기 전에 Connection 헤더와 기술되어 있던 모든 헤더를 삭제한다.


### 4.3.2. 순차적인 트랜잭션 처리에 의한 지연
- 예) 이미지 3개가 있는 웹페이지를 보여주려면 -> HTML, 이미지를 받기위해 각 트랜잭션 필요.
- 순차적인 처리로 인한 지연 발생. 로딩까지 빈 화면을 보고 있어 사용자 경험에 좋지 않음.
- 병렬 커넥션, 지속 커넥션, 파이프라인 커넥션으로 성능 향상 가능

## 4.4 병렬 커넥션
- 클라이언트가 여러 커넥션을 맺어 트랜잭션을 병렬로 처리
- 커넥션 대역폭 제한을 줄이고 각 커넥션의 지연 시간을 겹치게 하면 총 지연시간을 줄일 수 있음(대역폭을 한 커넥션에서 다 쓰지 않고 나눠서 활용)
- 단 대역폭이 좁을 때 여러 객체를 병렬로 받으면 느리다.
- 다수 커넥션은 메모리를 많이 소모하고 고부하 발생할 수 있음.
- 브라우저는 6-8개 병렬 커넥션만 허용
- 실제로 더 빠르게 객체를 받는 건 아니지만 여러 객체가 동시에 보이면서 사용자는 빠르다고 느낄 수 있다.
- 단점
    - 각 트랜잭션마다 새로 커넥션을 맺고 끊기 때문에 시간, 대역폭 소모
    - 각 커넥션은 TCP 느린시작 -> 성능 떨어짐
    - 병렬 커넥션 수 제한
    
## 4.5 지속 커넥션
- 사이트 지역성: 서버에 HTTP요청 후 같은 서버에 또 요청을 보냄
- HTTP/1.1에서는 요청 처리 완료 후에도 TCP 커넥션을 유지하여 HTTP 요청에 재사용 => 지속 커넥션.
    - 클라이언트나 서버가 커넥션을 끊기 전까지는 트랜잭션 간에도 커넥션 유지
    - 커넥션 준비 시간 절약
    - 튜닝된 커넥션 유지하여 커넥션 수를 줄임
- 적은 수의 병렬 커넥션만 맺고 유지하는 것이 가장 효과적

### 4.5.1 Keep-Alive
- 매 트랜잭션 마다 커넥션을 맺지 않고 하나의 지속 커넥션으로 처리 -> 커넥션을 맺고 끊는 작업이 없어서 시간 단축
- HTTP/1.1 명세에서는 빠졌지만 핸드셰이크가 널리 사용되고 있어서 처리되게는 해야함
- ```Connection:Keep-Alive``` 헤더 포함하여 커넥션 유지 요청을 보냄
    - 응답에도 같은 헤더를 보내서 같은 커넥션을 통해 요청을 받을 것을 알림. 없으면 끊을 것을 의미
    - '커넥션을 유지하고 싶다'는 요청
    - ```max``` : 몇개의 트랜잭션을 처리할 때까지 유지할 것인지
    -```timeout```: 얼마간 유지
    - ```Content-length```로 엔터티 본문의 길이를 알수 있어야 커넥션 유지 가능
    - 프락시와 게이트웨이는 Conenction 헤더의 규칙을 지켜야 한다. 메시지 전달 전 Connection에 명시된 헤더필드와 헤더를 제거해야함
- 멍청한 프락시
  - ```Connection:Keep-Alive``` 가 있으면 TCP 커넥션을 끊지 않겠다는 말인데
  - 프락시는 이 헤더를 이해하지 못해서 해당 헤더를 삭제하지 않고 요청 그대로를 다음 프록시에 전달
  - 클라이언트 - 프락시 - 서버 의 상황에서 클라이언트가 보낸 ```Connection:Keep-Alive``` 헤더를 이해하지 못하고 그대로 서버에 전달
  - 서버는 프락시가 커넥션을 유지하자고 요청한다고 생각. 동의해서 ```Connection:Keep-Alive``` 헤더를 포함해서 응답
  - 프락시는 응답을 클라이언트에 전달하고 서버에서 커넥션 끊기를 기다림(모른다 Keep-Alive..)
  - 클라이언트는 다음 요청을 보내기 시작 
  - 같은 커넥션에서 요청을 받은 프락시는 예상하지 못한 경우라 해당 요청을 무시. 브라우저에서는 로드 중이라는 표시만 나옴
    - 프락시는 ```Connection``` 헤더와 거기에 명시된 헤더를 절대 전달하면 안 된다!

### 4.5.2 Proxy-Connection
- 클라이언트 요청이 중개서버를 통할때 모든 헤더가 전달되는 문제 해결을 위해 Proxy-Connection 헤더 사용
- Connection 헤더 대신에 비표준인 ```Proxy-Connection:Keep-Alive``` 으로 보내면 서버에서 무시하고 Connection 을 응답헤더에 보내지 않음 -> Keep-Alive 커넥션이 맺어지지 않는다.
- 영리한(지속 커넥션 핸드셰이킹을 이해할 수 있는) 프락시는 이 헤더를 Connection헤더로 바꿔서 보냄 

### 4.5.3 HTTP/1.1 의 지속 커넥션
- Keep-Alive 커넥션을 지원하지 않지만 개선된 지속 커넥션 지원
- 지속커넥션은 기본으로 활성화 되어있음. 모든 커넥션은 지속임
- 끊고 싶으면 ```Connection: close``` 헤더를 명시

### 4.5.4 지속커넥션 규칙
- 요청에 Connection: close를 보냈으면 그 커넥션으로 추가 요청을 보낼 수 없다 => 그 커넥션으로 더 안보낼 때 해당 헤더를 보냄
- 커넥션에 있는 모든 메세지가 자기 길이 정보를 가지고 있을 때만 커넥션 지속 가능
- HTTP/1.1 프락시는 클라이언트와 서버 각각에 별도의 지속커넥션을 맺고 관리해야 함
- 서버는 Connection헤더값과 상관없이 언제든 커넥션을 끊을 수 있다.
- HTTP/1.1 애플리케이션은 중간에 끊어지는 커넥션을 복구할 수 있어야 함
- 사용자 당 두 개의 지속 커넥션만 유지해야 함(n명 사용자 2n 커넥션)

## 4.6 파이프라인 커넥션
- HTTP/1.1은 지속커넥션을 통해 요청을 파이프라이닝 할 수 있다.
- 요청은 응답이 도착하기 전에 큐에 쌓인다
- 첫번째 요청 완료 후 다음 요청 전달
- 응답은 요청 순서와 같에 와야 한다
- 커넥션이 끊어지더라도 완료되지 않은 요청이 파이프라인에 있으면 다시 요청을 보낼 준비가 되어 있어야 한다.
- POST 요청처럼 반복해서 보내면 문제가 있는 요청은 파이프라인을 통하면 안된다.

## 4.7 커넥션 끊기
- 클라이언트, 서버, 프락시 언제든 커넥션을 끊을 수 있다.
- 각 HTTP 응답은 본문의 정확한 크기를 가지는 ```Content-Length``` 헤더를 가져야 한다.
- 커넥션이 끊어졌다는 응답을 받고 전달된 엔터티의 길이와 ```Content-Length``` 값 비교 -> 다르거나 헤더가 없으면 서버에 물어봐야 함
- 멱등 트랜잭션(여러번 실행과 상관없이 같은 결과를 반환하는 트랜잭션) - GET, HEAD, PUT, DELETE, TRACE
- POST 처럼 멱등이 아닌 트랜잭션은 파이프라인을 통해 요청하면 안 된다. 반복 요청하면 안 되니까
- TCP 커넥션은 양방향이다.
  - 양쪽에는 데이터를 읽고 쓰는 입력, 출력 큐가 있다
  - ```close()```: 입출력 채널의 커넥션을 모두 끊는다.(전체 끊기)
  - ```shutdown()```: 입출력 중 개별적으로 끊음(절반 끊기)
- 보통은 커넥션 출력 채널을 끊는 것이 안전
- 클라이언트에서 더 데이터를 보내지 않는다고 확신하지 않는 이상 입력채널을 끊는 것은 위험
  - 끊긴 입력 채널에 데이터를 전송하면 운영체제에서는 에러 취급하 
  - 파이프라인 지속 커넥션을 통해 전송한 요청이 있는데 서버에서 연결을 끊으면 다음 요청이 종료된 커넥션에 보내짐 -> 버퍼에 저장된 데이터를 모두 삭제
- 애플리케이션 자신의 출력 채널을 먼저 끊고 따른 쪽의 출력 채널이 끊기는 걸 기다리는게 낫다.

