# 11. 클라이언트 식별과 쿠키

- HTTP 는 익명, 상태가 없고, 요청-응답으로 통신하는 프로토콜
- 웹 사이트들이 개인화된 서비스를 제공하고 싶어함 -> 사용자의 브라우징 기록 등으로 사이트를 개인화시켜 제공
    - 개별 인사: 사용자에 특화된 환영 메시지나 페이지 내용
    - 사용자 맞춤 추천: 고객 흥미를 학습해서 제품 추천
    - 지정된 사용자 정보: 매번 입력해야 하는 정보를 저장. 다음 번에 사용자를 식별하여 해당 정보 사용하도록 함
    - 세션 추적: HTTP트랜잭션은 상태가 없고 요청과 응답이 독립적으로 일어난다. 사용자의 상태를 남겨 상태를 유지

## HTTP 헤더로 사용자 식별
1. ```From```
   1. 사용자의 이메일 주소
   2. 악의적 서버가 스팸메일을 발송하는 경우가 있어서 From 헤더를 잘 보내진 않음
2. ```User-Agent```
   1. 사용 브라우저의 이름과 버전 정보, 운영체제에 대한 정보
   2. 특정 브라우저에서 동작하도록 속성에 맞춰 콘텐츠를 최적화
3. ```Referer```
   1. 현재 페이지로 유입하게 한 URL
   2. 이전에 어떤 페이지를 방문했는지 알려줌 -> 사용 행태나 취향 파악

## 클라이언트 IP로 식별
- 사용자가 확실한 IP주소가 있고 바뀌지 않고 요청마다 IP를 파악할 수 있다면 문제없이 동작
- 헤더에 IP주소를 포함하지 않지만 HTTP 요청을 보내는 반대쪽 TCP 커넥션의 IP주소를 알아낼 수 있다.
- IP주소는 사용자가 아닌 사용자의 컴퓨너틑 가리켜 같은 컴퓨터를 여러 사용자가 사용할 때 식별할 수 없다
- 동적 IP 할당으로 시간마다 다른 IP주소가 생성된다
- 보안이슈로 NAT 방화벽을 통해 인터넷을 사용하면 실제 ip주소가 숨겨지고 그걸 내부에서 사용하는 방화벽 ip주소로 변환한다
- http 프락시와 게이트웨이틑 원 서버에 새로운 tcp연결을 한다 -> 웹 서버는 프락시의 ip주소를 본다(클라이언트 아님)

## 사용자 로그인으로 식별
- 사용자 이름과 비밀번호로 인증 요구 -> 명시적 식별 요청
- ```WWW-Authenticate```, ```Authorization```헤더
- 사이트 접근 전 로그인이 필요하면 401 상태코드와 WWW-Authenticate헤더 반환하여 로그인 요청
- 식별정보를 보내고 이후 요청에 대해서 브라우저에서 사용자 이름과 비밀번호를 Authorization 헤더에 담아 같이 전달. 세션이 진행되는 동안 식별 유지

## 뚱뚱한 URL
- 사용자의 상태정보를 포함하는 url
- 사용자 url 마다 버전을 기술하여 사용자의 식별, 추적
- 웹 서버에서 url에 있는 상태 정보를 유지하는 하이퍼링크를 동적으로 생성
- 웹사이트 방문 > 유일 id생성 > 서버가 인식할 수 있는 방식으로 url에 추가 > 이 url로 리다이렉트 시킴
- 서버가 이 url 요청을 받으면 사용자 정보를 찾아서 밖으로 향하는 모든 링크를 이 url로 바꾼다
- url 공유하게되면 본인 정보를 공유하게 됨
- 캐시 사용 불가
- url에 해당하는 html을 그려야 하므로 서버 부하 가중
- 의도치않게 세션에서 이탈ㄷ괴기 쉬움

## 쿠키
### 쿠키의 타입
   1. 세션쿠키
      1. 사용자가 사이트를 탐색할 때 관련한 설정과 선호 사항을 저장하는 임시 쿠키. 브라우저 닫으면 삭제됨
   2. 지속쿠키
      1. 디스크에 저장되어 브라우저를 닫거나 재부팅을 해도 남아있다. 주기적으로 방문하는 사이트에 대한 설정정보느 로그인 이름을 유지할 때 사용
      
### 쿠키의 동작
- 서버가 붙이는 사용자 정보 스티커와 같음
- 사용자가 다시 돌아왔을 때 해당 사용자를 식별하기 위해 유일한 값을 쿠키에 할당(이름=값)
- ```Set-Cookie```같은 응답 헤더에 기술되어 전달
- 브라우저가 서버관련 정보를 저장하고 사용자가 해당 서버에 접근할 때마다 그 정보를 함께 전송
- 브라우저는 쿠키정보를 저장해야함(클라이언트 측 상태) "HTTP State Management Mechanism"
- 각 사이트에 두세개의 쿠키를 보낸다
  - 쿠키를 모두 전달하면 성능 저하
  - 쿠키들이 대부분 서버에 특화된 이름/값 쌍을 포함하여 대부분 ㅅ하이트에서는 인식하지 않는 무의미한 값
  - 개인정보 문제(특정 사이트에서 저장된걸 다른 곳에 전달)
- 보통 브라우저는 쿠키를 생성한 서버에게만 쿠키에 담긴 정보를 저장
- ```Set-Cookie``` 응답헤더에 ```Domain``` 속성으로 어떤 사이트가 그 쿠기를 읽을 수 있는지 제어
  - 예) ```Set-Cookie: user="mary"; domain="joe.com"``` : 사용자가 www.joe.com이나 specials.joe.com같이 해당 도메인으로 끝나는 사이트를 방문하면 user 쿠키 헤더가 항상 적용됨
- Path: 웹 사이트 일부에만 쿠키를 적용. 해당 경로에 속하는 페이지만 쿠키를 전달하도록
  - 예) ```Set-Cookie: pref=compact; domain="joe.com"; path=/autos/```: 사용자가 www.joe.com/autos에 접근하면 user쿠키, pref쿠키를 받음. 
- 쿠키=상태 정보
- 서버가 생성하여 클라이언트에 전달
- 클라이언튼는 그 쿠키를 유효한 사이트에만 전달하고 관리

### 쿠키와 세션 추적
- 웹사이트에 수차례 트랜잭션을 만들어내는 사용자 추적에 사용
- amazon.com에 방문하면;
  - amazon.com 루트페이지 get 요청
  - 특정 url로 리다이렉트
  - 그 url로 다시 요청
  - 두 세션쿠키를 기술하고 다른 url로 리다이렉트
  - 쿠키를 첨부하여 요청 보냄(사용자 정보를 가진 뚱뚱한 url)
  - 서버는 home으로 리다이렉트 시키고 쿠키 두개를 더 첨부
  - home을 가져오고 네개 쿠키를 전달
  - 서버에서 콘텐츠 보냄

### 쿠키와 캐싱
- 쿠키 트랜잭션과 관련된 문서는 이전 사용자 쿠키가 다른 사용자에게 할당되거나 개인정보가 노출될 수 있으니 주의
- 캐시되지 말아야 할 문서가 있다면 표시한다.(```Cache-Control: no-cache="Set-Cooke"```)
- Set-Cookie 헤더 캐시에 유의
  - 그 헤더 캐시해서 여러 사용자에게 보내면 사용자 추적에 실패하니 본문은 캐시해도 헤더를 캐시하는 것에 주의한다
- 요청이 Cookie 헤더와 오면 결과가 개인정보를 담고있을 수 있다는 것. 보수적 캐시는 Cookie 헤더가 포함된 요청에 대한 응답은 캐시하지 않을 것. 파기시간을 0인 Cookie 헤더를 설정해서 매번 재검사를 하도록 함
