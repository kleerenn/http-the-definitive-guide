# 13. 다이제스트 인증
- 기본 인증을 대체하기 위해 설계
- 잘 쓰이지는 않지만 보안 트랜잭션 구현을 위한 개념을 이해하자!

## 다이제스트 인증의 특징
1. 단방향 요약
- 비밀번호를 절대로 평문으로 전송하지 않고 비 가역적으로 뒤섞은 핑거프린팅 혹은 요약(digest)을 보낸다
  - 클라이언트가 서버에 비밀번호 요약을 보내고 서버는 스스로 계산한 요약과 일치하는지 비교
  - 네트워크를 통해 비밀번호가 전송되지 않음
  - 요약이란? 정보 본문의 압축
  - 요약은 단방향 함수로 동작, 입력값을 유한한 범위의 압축으로 변환
  - 요약함수는 암호 체크섬으로 불리며 단방향 해시 함수, 지문함수(fingerprint function)이다.

2. 재전송 방지를 위한 난스
- 비밀번호를 그대로 보내진 않아도 요약을 가로채서 재 전송할 수 있음 -> 서버에서 난스(nounce)를 건네준다.
- 난스를 비밀번호에 섞어서 요약도 바뀌도록
- 난스는 WWW-Authenticate 인증 요구에 담겨서 서버-클라이언트로 넘겨진다

3. 다이제스트 인증 핸드 셰이크
- 서버에서 난스 값 계산하여 WWW-Authenticate 인증 요구 메세지에 알고리즘과 함께 보냄
- 클라이언트를 알고리즘을 선택하고 비번과 요약을 계산하여 Authorization 메시지에 요약을 담아 보냄
- 서버에서 받은 요약을 계산하여 자신의 계산과 같은지 확인

## 요약 계산
- 다이제스트 인증 => 공개된 정보, 비밀정보, 시한부 난스값을 조합한 단방향 요약

1.요약 계산에 필요한 요소
  1) 단방향 해시함수(H(d)), 요약함수(KD(s,d))
    - 여러 요약 알고리즘을 선택할 수 있도록 지원(MD5가 기본)
  2) 보안정보를 담은 데이터(A1)
      - 사용자 이름, 비밀번호, 보호영역, 난스
      - 메시지 자체가 아닌 비밀정보와만 연관
  3) 요청 메세지의 비밀이 아닌 속성을 담은 데이터(A2)
      - URL, 요청 메서드, 메시지 엔터티 본문과 같은 메시지 자체의 정보
- 비밀정보와 난스가 붙은 메세지 데이터의 해시를 이용해 요약 계산
- 난스 횟수 집계, 대체 인증 지원 포함

2. 다이제스트 인증 세션
- WWW-Authenticate 인증 요구에 대한 응답으로 인증 세션 세작 -> 다른 서버로 부터 다른 인증요구를 받을 때까지 지속됨
- 사용자 이름, 비밀번호, 난스, 난스횟수, 인증세션과 연관된 값을 기억해야 함
- 난스가 만료되면 Authorization 헤더 정보를 받아들임거나 서버에서 새 난스값과 401 반환

3. 사전 인가
- 일반적으로 요청은 트랜잭션이 완료되기 전 요청/인증요구 사이클이 필요
- 서버가 물어보기 전에 클라이언트가 Authorization헤더를 생성할 수 있으면 위 사이클 생략하고 바로 서버에 헤더 제공
- 사용자가 한번 인증을 하면 브라우저는 그 URL에 대한 요청 때 올바른 Authorization 헤더를 전송
- 난스를 이용한 다이제스트 인증에서는 서버에서 임의의 난스를 생성함 -> 인증요구를 받기 전에 미리 맞는 Authorization 헤더를 알 수 없다
  - 서버가 다음 난스를 Authentication-Info 헤더에 담아서 보내거나(다중요청 파이프라이닝은 안됨)
  - 짧은 기간동안 같은 난스를 재사용하는 것을 허용하거나(파이프라이닝 가능)
  - 클라이언트와 서버가 동기화 되어있고 예측 가능한 난스 생성 알고리즘을 사용하면 올바른 난스를 취득할 수 있다.

4. 난스 선택
- 가상의 난스 공식: BASE64(타임스탬프 H(타임스탬프":" ETag ":" 개인키))
- 타임스탬프는 서버에서 생성된 시간, 반복 불가능한 값
- ETag: 요청 엔터티에 대한 ETag 헤더값
- 개인키: 서버만이 알고 있는 값

5. 상호인증
- 서버가 공유된 비밀정보에 근거한 올바른 응답 요약을 생성하도록 클라이언트에 난스값을 전달. 
- RFC 2617로 표준화됨

## 보호수준(qop) 향상
- qop필드는 요약헤더의 WWW-Authenticate, Authorization, Authentication-Info에 모두 존재할 수 있음
- 클라이언트와 서버가 어떤 보호기법을 어느 정도 수준으로 사용할지 협상할 수 있게 함
- WWW-Authenticate 헤더에 qop 옵션을 쉼표로 구분된 목록 형태로 보내고 -> 클라이언트가 그 옵션을 선택하고 Authorization헤더의 qop 필드에 담아 보냄

## 실제 상황에 대한 고려
1. 다중 인증 요구: 서버는 한 리소스에 대해 여러 인증을 할 수 있다. (기본, 다이제스트 인증)
2. 오류 처리: 지시자나 값이 적절하지 않거나 요구된 지시자가 빠져있을 때는 400 Bad REquest. 로그인 실패를 기록해둬야 함.
3. 보호 공간
    - 영역값은 접근한 서버의 루트 url과 결합하여 보호공간 정의
    - 서버의 보호된 리소스들을 인증제도와 인가 데이터베이스를 가진 보호 영역으 집합으로 분할
    - 원 서버에 의해 할당되는 문자열
    - 보호공간은 어떤 자격이 자동으로 적용되는 영역을 결정
    - 기본 인증에서 요청 uri와 하위 모든 경로는 같은 보호 공간에 있는 것으로 가정하여 이 공간에서 버서로부터 다른 인증 요구를 기다리지 않고 미리 리소스에 대한 인가를 받는다
    - 다이제스트 인증에서 인증요구의 WWW-Authenticate:domain은 보호공간을 엄밀히 정의. uri의 공백으로 분리된 목록으로 모든 uri와 논리적으로 그 하위에 위치한 모든 uri는 같은 보호 공간에 있는 것으로 가정
4. uri 다시 쓰기
    - 프락시는 가리키는 리소스의 변경업이 구문만 고쳐서 uri를 다시 쓰기도 함(호스트명 정규화 혹은 ip주소로 대체, 타입에 대한 속성 삽입)
    - 프락시가 uri를 변경하면서 다이제스트 인증은 uri값의 무결성을 검사하므로 다이제스트 인증이 이러한 변경에 의해 실패할 수 있음
5. 캐시
   - 공유 캐시가 Authorization 헤더를 포함한 요청과 응답을 받을 때 두 Cache-Control 지시자 중 하나가 응답에 존재하지 않는 한 다른 요청에 대하 그 응답을 반환하면 안 된다.


## 보안에 대한 고려
1. 헤더 부당 변경: 헤더 부당 변경에 대해 양 종단 암호화나 헤더에 대한 디지털 서명이 필요
2. 재전송 공격
   - GET 요청 뿐 아니라 POST, PUT 요청에 대한 재전송 공격에도 대비가 있어야 함
   - 클라이언트ip주소, 타임스탬프, ETag, 개인서버키에 대한 요약을 포함하는 난스를 서버가 생성하도록 해야함.
   - 매 트랜잭션 마다 유일한 난스값을 사용하여 재전송 공격을 피한다
3. 다중 인증 메커니즘: 서버가 다중 인증 제도를 지원하고 선택지를 제공함. 클라이언트가 가장 강력한 인증제도를 선택한다.
4. 사전(dictionary) 공격
   - 악의적인 사용자가 트랜잭션을 엿보고 난스-응답 쌍에 대해 비밀번호를 추측할 수 있음
   - 복잡한 비밀번호를 사용하자
5. 악의적인 프락시와 중간자 공격: 요청이 프락시를 통과하면서 중간자 공격에 취약해 질 수 있음
6. 선택 평문 공격
   - 서버가 아니라 프락시에서 난스를 제공함
   - 공격 서버는 미리 결정된 난스와 자주 쓰이는 비밀번호로 응답 집합을 생성하여 사전을 만든다,
   - 공격 서버/프락시는 트래픽을 차단하고 미리 결정된 난스를 클라이언트로 전송
   - 클라이언트에서 응답을 받아 사전에서 찾으면 비밀번호는 획득된 것
   - 클라이언트가 서버에서 제공된 난스 대신 선택적인 c난스 지시자를 사용하여 응답을 생성하도록 설정
